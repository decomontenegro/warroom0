import { useEffect, useRef, useState } from 'react'
import * as d3 from 'd3'
import './AgentNetworkMap.css'

function AgentNetworkMap({ 
  agents, 
  activeConnections = [], 
  expanded = false, 
  onExpand,
  onClose,
  currentPhase = 0 
}) {
  const svgRef = useRef(null)
  const simulationRef = useRef(null)
  const [hoveredNode, setHoveredNode] = useState(null)
  const [dimensions, setDimensions] = useState({ width: 300, height: 300 })
  const [layout, setLayout] = useState('force')
  const [isDynamic, setIsDynamic] = useState(true)
  const [animationProgress, setAnimationProgress] = useState(0)
  
  // Atualizar dimensões baseado no modo expandido
  useEffect(() => {
    if (expanded) {
      setDimensions({ 
        width: window.innerWidth * 0.8, 
        height: window.innerHeight * 0.8 
      })
    } else {
      setDimensions({ width: 300, height: 300 })
    }
  }, [expanded])

  useEffect(() => {
    if (!svgRef.current || !agents || agents.length === 0) return

    const { width, height } = dimensions
    const centerX = width / 2
    const centerY = height / 2
    
    // Limpar SVG e parar simulação anterior
    d3.select(svgRef.current).selectAll('*').remove()
    if (simulationRef.current) {
      simulationRef.current.stop()
    }

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height)

    // Adicionar definições para gradientes e filtros
    const defs = svg.append('defs')
    
    // Gradiente para conexões ativas
    const gradient = defs.append('linearGradient')
      .attr('id', 'connectionGradient')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '100%')
      .attr('y2', '0%')
    
    gradient.append('stop')
      .attr('offset', '0%')
      .style('stop-color', '#3b82f6')
      .style('stop-opacity', 0.2)
    
    gradient.append('stop')
      .attr('offset', '50%')
      .style('stop-color', '#3b82f6')
      .style('stop-opacity', 1)
    
    gradient.append('stop')
      .attr('offset', '100%')
      .style('stop-color', '#3b82f6')
      .style('stop-opacity', 0.2)

    // Filtro de glow
    const filter = defs.append('filter')
      .attr('id', 'glow')
    
    filter.append('feGaussianBlur')
      .attr('stdDeviation', '3')
      .attr('result', 'coloredBlur')
    
    const feMerge = filter.append('feMerge')
    feMerge.append('feMergeNode').attr('in', 'coloredBlur')
    feMerge.append('feMergeNode').attr('in', 'SourceGraphic')

    // Preparar dados dos nós
    const nodes = [
      {
        id: 'orchestrator',
        label: 'Orquestrador',
        type: 'central',
        x: centerX,
        y: centerY - (layout === 'force' ? 30 : 0),
        color: '#8b5cf6',
        radius: expanded ? 20 : 12,
        fx: layout !== 'force' ? centerX : undefined,
        fy: layout !== 'force' ? centerY - (layout === 'hierarchical' ? height * 0.1 : 0) : undefined
      },
      {
        id: 'chief',
        label: 'Chief Strategy Officer',
        type: 'central',
        x: centerX,
        y: centerY + (layout === 'force' ? 30 : 0),
        color: '#ffc107',
        radius: expanded ? 20 : 12,
        fx: layout !== 'force' ? centerX : undefined,
        fy: layout !== 'force' ? centerY + (layout === 'hierarchical' ? height * 0.1 : 0) : undefined
      }
    ]

    // Aplicar layout aos agentes
    const applyLayout = () => {
      switch(layout) {
        case 'radial': {
          const radialRadius = expanded ? Math.min(width, height) * 0.35 : 100
          const layers = {
            0: agents.slice(0, 20),   // Camada interna
            1: agents.slice(20, 50),  // Camada média
            2: agents.slice(50)       // Camada externa
          }
          
          let nodeIndex = 0
          Object.entries(layers).forEach(([layerIndex, layerAgents]) => {
            const layerRadiusBase = radialRadius * (0.4 + parseInt(layerIndex) * 0.3)
            layerAgents.forEach((agent, i) => {
              // Adicionar variação dinâmica ao raio
              const radiusVariation = isDynamic ? Math.sin(Date.now() * 0.001 + nodeIndex * 0.5) * 10 : 0
              const radius = layerRadiusBase + radiusVariation
              
              // Adicionar rotação contínua suave
              const rotationSpeed = isDynamic ? 0.0002 * (parseInt(layerIndex) + 1) : 0
              const angle = (i / layerAgents.length) * 2 * Math.PI - Math.PI / 2 + (Date.now() * rotationSpeed)
              
              const x = centerX + radius * Math.cos(angle)
              const y = centerY + radius * Math.sin(angle)
              nodes.push({
                id: agent.id,
                label: agent.name,
                type: agent.category || 'agent',
                x: x,
                y: y,
                targetX: x,
                targetY: y,
                fx: !isDynamic ? x : undefined,
                fy: !isDynamic ? y : undefined,
                color: getAgentColor(agent),
                radius: expanded ? 8 : 4,
                agent: agent,
                layerIndex: parseInt(layerIndex),
                angleIndex: i,
                totalInLayer: layerAgents.length
              })
              nodeIndex++
            })
          })
          break
        }
        
        case 'hierarchical': {
          const levels = {
            1: agents.slice(0, 10),   // Nível 1
            2: agents.slice(10, 30),  // Nível 2
            3: agents.slice(30, 60),  // Nível 3
            4: agents.slice(60)       // Nível 4
          }
          
          const levelHeight = height / (Object.keys(levels).length + 2)
          
          Object.entries(levels).forEach(([level, levelAgents]) => {
            const levelY = levelHeight * (parseInt(level) + 1)
            const levelWidth = width / (levelAgents.length + 1)
            
            levelAgents.forEach((agent, i) => {
              // Adicionar ondulação horizontal
              const waveAmplitude = isDynamic ? 15 : 0
              const waveFrequency = 0.001
              const waveOffset = isDynamic ? Math.sin(Date.now() * waveFrequency + i * 0.5) * waveAmplitude : 0
              
              // Adicionar flutuação vertical
              const floatAmplitude = isDynamic ? 5 : 0
              const floatOffset = isDynamic ? Math.sin(Date.now() * 0.002 + parseInt(level) * Math.PI / 2) * floatAmplitude : 0
              
              const x = (i + 1) * levelWidth + waveOffset
              const y = levelY + floatOffset
              nodes.push({
                id: agent.id,
                label: agent.name,
                type: agent.category || 'agent',
                x: x,
                y: y,
                targetX: x,
                targetY: y,
                fx: !isDynamic ? x : undefined,
                fy: !isDynamic ? y : undefined,
                color: getAgentColor(agent),
                radius: expanded ? 8 : 4,
                agent: agent,
                level: parseInt(level),
                indexInLevel: i
              })
            })
          })
          break
        }
        
        case 'circular': {
          const baseRadius = Math.min(width, height) * 0.4
          agents.forEach((agent, i) => {
            const angle = (i / agents.length) * 2 * Math.PI
            
            // Adicionar pulsação do círculo
            const pulseAmplitude = isDynamic ? 20 : 0
            const pulseSpeed = 0.001
            const radiusPulse = isDynamic ? Math.sin(Date.now() * pulseSpeed + i * 0.1) * pulseAmplitude : 0
            
            // Adicionar rotação do círculo inteiro
            const rotationSpeed = isDynamic ? 0.0003 : 0
            const rotatedAngle = angle + (Date.now() * rotationSpeed)
            
            const circleRadius = baseRadius + radiusPulse
            const x = centerX + circleRadius * Math.cos(rotatedAngle)
            const y = centerY + circleRadius * Math.sin(rotatedAngle)
            nodes.push({
              id: agent.id,
              label: agent.name,
              type: agent.category || 'agent',
              x: x,
              y: y,
              targetX: x,
              targetY: y,
              fx: !isDynamic ? x : undefined,
              fy: !isDynamic ? y : undefined,
              color: getAgentColor(agent),
              radius: expanded ? 8 : 4,
              agent: agent,
              angleIndex: i,
              totalNodes: agents.length
            })
          })
          break
        }
        
        default: // force layout
          const agentRadius = expanded ? Math.min(width, height) * 0.35 : 100
          const innerRadius = agentRadius * 0.6
          const outerRadius = agentRadius
          const coreAgents = agents.slice(0, 50)
          const supportAgents = agents.slice(50)
          
          coreAgents.forEach((agent, i) => {
            const angle = (i / coreAgents.length) * 2 * Math.PI - Math.PI / 2
            nodes.push({
              id: agent.id,
              label: agent.name,
              type: agent.category || 'agent',
              x: centerX + innerRadius * Math.cos(angle),
              y: centerY + innerRadius * Math.sin(angle),
              color: getAgentColor(agent),
              radius: expanded ? 8 : 4,
              agent: agent
            })
          })
          
          supportAgents.forEach((agent, i) => {
            const angle = (i / supportAgents.length) * 2 * Math.PI - Math.PI / 2
            nodes.push({
              id: agent.id,
              label: agent.name,
              type: agent.category || 'agent',
              x: centerX + outerRadius * Math.cos(angle),
              y: centerY + outerRadius * Math.sin(angle),
              color: getAgentColor(agent),
              radius: expanded ? 8 : 4,
              agent: agent
            })
          })
      }
    }
    
    applyLayout()

    // Criar links base (todos conectados aos nós centrais)
    const links = []
    agents.forEach(agent => {
      links.push({
        source: agent.id,
        target: 'orchestrator',
        active: false
      })
      links.push({
        source: agent.id,
        target: 'chief',
        active: false
      })
    })

    // Adicionar grupo para zoom/pan
    const g = svg.append('g')
    
    // Configurar simulação de força
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(expanded ? 150 : 50))
      .force('charge', d3.forceManyBody().strength(expanded ? -300 : -100))
      .force('center', d3.forceCenter(centerX, centerY))
      .force('collision', d3.forceCollide().radius(d => d.radius + 5))
    
    simulationRef.current = simulation
    
    // Primeiro, parar qualquer simulação anterior
    if (layout === 'force' && isDynamic) {
      simulation.alpha(1).restart()
    } else {
      simulation.stop()
      // Para layouts estáticos, forçar posições fixas
      if (!isDynamic) {
        nodes.forEach(d => {
          if (d.fx !== undefined) d.x = d.fx
          if (d.fy !== undefined) d.y = d.fy
        })
      }
    }

    // Renderizar links
    const linkGroup = g.append('g').attr('class', 'links')
    
    const linkElements = linkGroup.selectAll('line')
      .data(links)
      .enter()
      .append('line')
      .attr('x1', d => {
        const sourceNode = nodes.find(n => n.id === d.source)
        return sourceNode ? sourceNode.x : 0
      })
      .attr('y1', d => {
        const sourceNode = nodes.find(n => n.id === d.source)
        return sourceNode ? sourceNode.y : 0
      })
      .attr('x2', d => {
        const targetNode = nodes.find(n => n.id === d.target)
        return targetNode ? targetNode.x : 0
      })
      .attr('y2', d => {
        const targetNode = nodes.find(n => n.id === d.target)
        return targetNode ? targetNode.y : 0
      })
      .attr('stroke', '#333')
      .attr('stroke-width', 0.5)
      .attr('opacity', 0.1)
      .attr('class', 'network-link')

    // Renderizar nós
    const nodeGroup = g.append('g').attr('class', 'nodes')
    
    const nodeElements = nodeGroup.selectAll('g')
      .data(nodes)
      .enter()
      .append('g')
      .attr('transform', d => `translate(${d.x}, ${d.y})`)
      .style('cursor', 'pointer')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended)
      )
      .on('mouseenter', function(event, d) {
        setHoveredNode(d)
        d3.select(this).select('circle')
          .transition()
          .duration(200)
          .attr('r', d.radius * 1.5)
      })
      .on('mouseleave', function(event, d) {
        setHoveredNode(null)
        d3.select(this).select('circle')
          .transition()
          .duration(200)
          .attr('r', d.radius)
      })

    // Adicionar círculos aos nós
    nodeElements.append('circle')
      .attr('r', d => d.radius)
      .attr('fill', d => d.color)
      .attr('filter', d => d.type === 'central' ? 'url(#glow)' : null)
      .attr('opacity', 0.9)

    // Adicionar labels apenas no modo expandido ou para nós centrais
    if (expanded) {
      nodeElements.append('text')
        .text(d => d.label.split(' ')[0])
        .attr('text-anchor', 'middle')
        .attr('dy', d => d.radius + 15)
        .attr('font-size', '10px')
        .attr('fill', '#ccc')
        .attr('opacity', 0.8)
    } else {
      // Apenas labels dos nós centrais
      nodeElements.filter(d => d.type === 'central')
        .append('text')
        .text(d => d.label.split(' ')[0])
        .attr('text-anchor', 'middle')
        .attr('dy', d => d.radius + 12)
        .attr('font-size', '9px')
        .attr('fill', '#ccc')
    }

    // Animar conexões ativas
    activeConnections.forEach(conn => {
      const link = linkElements.filter(d => 
        (d.source === conn.from && d.target === conn.to) ||
        (d.source === conn.to && d.target === conn.from)
      )
      
      if (!link.empty()) {
        link
          .attr('stroke', 'url(#connectionGradient)')
          .attr('stroke-width', 2)
          .attr('opacity', 1)
          .attr('class', `network-link active-connection phase-${conn.phase || 1}`)
          
        // Adicionar animação de partícula
        const sourceNode = nodes.find(n => n.id === conn.from)
        const targetNode = nodes.find(n => n.id === conn.to)
        
        if (sourceNode && targetNode) {
          // Destacar nó de origem
          const sourceNodeElement = nodeElements.filter(d => d.id === conn.from)
          if (!sourceNodeElement.empty()) {
            sourceNodeElement.select('circle')
              .classed('node-active', true)
              .classed(`phase-${conn.phase || 1}`, true)
          }
          
          // Criar partícula animada
          const particle = g.append('circle')
            .attr('r', 3)
            .attr('fill', getPhaseColor(conn.phase))
            .attr('filter', 'url(#glow)')
            .attr('cx', sourceNode.x)
            .attr('cy', sourceNode.y)
            
          particle.transition()
            .duration(1000)
            .attr('cx', targetNode.x)
            .attr('cy', targetNode.y)
            .on('end', function() {
              d3.select(this).remove()
              // Remover destaque do nó após animação
              if (!sourceNodeElement.empty()) {
                sourceNodeElement.select('circle')
                  .classed('node-active', false)
                  .classed(`phase-${conn.phase || 1}`, false)
              }
            })
        }
      }
    })

    // Adicionar zoom/pan no modo expandido
    if (expanded) {
      const zoom = d3.zoom()
        .scaleExtent([0.5, 3])
        .on('zoom', (event) => {
          g.attr('transform', event.transform)
        })
      
      svg.call(zoom)
    }
    
    // Funções de drag
    function dragstarted(event, d) {
      if (!event.active && isDynamic && layout === 'force') simulation.alphaTarget(0.3).restart()
      d.fx = d.x
      d.fy = d.y
    }

    function dragged(event, d) {
      d.fx = event.x
      d.fy = event.y
      d.x = event.x
      d.y = event.y
      d3.select(this).attr('transform', `translate(${d.x}, ${d.y})`)
    }

    function dragended(event, d) {
      if (!event.active && isDynamic && layout === 'force') simulation.alphaTarget(0)
      if (isDynamic && layout === 'force') {
        d.fx = null
        d.fy = null
      }
    }
    
    // Atualizar simulação e animações
    if (layout === 'force' && isDynamic) {
      simulation.on('tick', () => {
        linkElements
          .attr('x1', d => d.source?.x || 0)
          .attr('y1', d => d.source?.y || 0)
          .attr('x2', d => d.target?.x || 0)
          .attr('y2', d => d.target?.y || 0)

        nodeElements
          .attr('transform', d => `translate(${d.x}, ${d.y})`)
      })
    } else if (isDynamic && layout !== 'force') {
      // Animação para layouts não-force
      let animationId
      const animate = () => {
        // Recalcular posições dos nós baseado no layout
        nodes.forEach((d, i) => {
          if (d.type === 'central') return // Não animar nós centrais
          
          switch(layout) {
            case 'radial': {
              const radialRadius = expanded ? Math.min(width, height) * 0.35 : 100
              const layerRadiusBase = radialRadius * (0.4 + d.layerIndex * 0.3)
              const radiusVariation = Math.sin(Date.now() * 0.001 + i * 0.5) * 10
              const radius = layerRadiusBase + radiusVariation
              const rotationSpeed = 0.0002 * (d.layerIndex + 1)
              const angle = (d.angleIndex / d.totalInLayer) * 2 * Math.PI - Math.PI / 2 + (Date.now() * rotationSpeed)
              d.x = centerX + radius * Math.cos(angle)
              d.y = centerY + radius * Math.sin(angle)
              break
            }
            case 'hierarchical': {
              const levelHeight = height / 6
              const levelWidth = width / (agents.filter(a => nodes.find(n => n.id === a.id && n.level === d.level)).length + 1)
              const waveAmplitude = 15
              const waveOffset = Math.sin(Date.now() * 0.001 + d.indexInLevel * 0.5) * waveAmplitude
              const floatOffset = Math.sin(Date.now() * 0.002 + d.level * Math.PI / 2) * 5
              d.x = (d.indexInLevel + 1) * levelWidth + waveOffset
              d.y = levelHeight * (d.level + 1) + floatOffset
              break
            }
            case 'circular': {
              const baseRadius = Math.min(width, height) * 0.4
              const angle = (d.angleIndex / d.totalNodes) * 2 * Math.PI
              const pulseAmplitude = 20
              const radiusPulse = Math.sin(Date.now() * 0.001 + d.angleIndex * 0.1) * pulseAmplitude
              const rotationSpeed = 0.0003
              const rotatedAngle = angle + (Date.now() * rotationSpeed)
              const circleRadius = baseRadius + radiusPulse
              d.x = centerX + circleRadius * Math.cos(rotatedAngle)
              d.y = centerY + circleRadius * Math.sin(rotatedAngle)
              break
            }
          }
        })
        
        // Atualizar posições visuais se os elementos existem
        if (nodeElements) {
          nodeElements.attr('transform', d => `translate(${d.x}, ${d.y})`)
        }
        
        // Atualizar links se existem
        if (linkElements) {
          linkElements
            .attr('x1', d => {
              const sourceNode = nodes.find(n => n.id === (d.source.id || d.source))
              return sourceNode ? sourceNode.x : 0
            })
            .attr('y1', d => {
              const sourceNode = nodes.find(n => n.id === (d.source.id || d.source))
              return sourceNode ? sourceNode.y : 0
            })
            .attr('x2', d => {
              const targetNode = nodes.find(n => n.id === (d.target.id || d.target))
              return targetNode ? targetNode.x : 0
            })
            .attr('y2', d => {
              const targetNode = nodes.find(n => n.id === (d.target.id || d.target))
              return targetNode ? targetNode.y : 0
            })
        }
        
        animationId = requestAnimationFrame(animate)
      }
      animate()
      
      // Retornar função de limpeza para cancelar animação
      return () => {
        if (animationId) {
          cancelAnimationFrame(animationId)
        }
      }
    }
    
    // Armazenar ID da anima\u00e7\u00e3o para limpeza
    let cleanupAnimationId
    
    // Limpar ao desmontar
    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop()
      }
      if (cleanupAnimationId) {
        cancelAnimationFrame(cleanupAnimationId)
      }
    }

  }, [agents, activeConnections, dimensions, expanded, layout, isDynamic])

  // Função para obter cor do agente baseado no tipo
  const getAgentColor = (agent) => {
    const colors = {
      'architecture': '#2563eb',
      'frontend': '#3b82f6',
      'backend': '#10b981',
      'security': '#ef4444',
      'database': '#f59e0b',
      'devops': '#06b6d4',
      'ai': '#8b5cf6',
      'business': '#ec4899',
      'design': '#f97316',
      'quality': '#84cc16'
    }
    
    // Tentar encontrar categoria por palavras-chave no nome/role
    const agentInfo = (agent.name + ' ' + agent.role).toLowerCase()
    for (const [key, color] of Object.entries(colors)) {
      if (agentInfo.includes(key)) return color
    }
    
    return '#6b7280' // cor padrão
  }
  
  // Função para obter cor baseada na fase
  const getPhaseColor = (phase) => {
    const phaseColors = {
      1: '#10b981', // Verde
      2: '#3b82f6', // Azul
      3: '#8b5cf6', // Roxo
      4: '#f59e0b', // Laranja
      5: '#ef4444', // Vermelho
      6: '#ec4899'  // Rosa
    }
    return phaseColors[phase] || '#3b82f6'
  }

  return (
    <div className={`agent-network-map ${expanded ? 'expanded' : 'mini'}`} data-layout={layout}>
      {!expanded && (
        <div className="network-header">
          <div>
            <span className="network-title">🗺️ Rede Neural</span>
            {activeConnections.length > 0 && (
              <span className="active-count">{activeConnections.length} ativos</span>
            )}
          </div>
          <button 
            className="expand-btn"
            onClick={onExpand}
            title="Expandir visualização"
          >
            ⛶
          </button>
        </div>
      )}
      
      {expanded && (
        <div className="network-controls">
          <div className="network-info">
            <h3>Rede Neural de Especialistas</h3>
            <p>Fase {currentPhase}/6 • {agents.length} agentes conectados</p>
          </div>
          <div className="layout-controls">
            <select 
              value={layout} 
              onChange={(e) => {
                const newLayout = e.target.value
                setLayout(newLayout)
                // Se mudando para layout não-force, ativar modo dinâmico por padrão
                if (newLayout !== 'force') {
                  setIsDynamic(true)
                }
              }}
              className="layout-select"
            >
              <option value="force">🌐 Force Directed</option>
              <option value="radial">⭕ Radial</option>
              <option value="hierarchical">📋 Hierárquico</option>
              <option value="circular">🔄 Circular</option>
            </select>
            <label className="dynamic-toggle">
              <input 
                type="checkbox" 
                checked={isDynamic} 
                onChange={(e) => setIsDynamic(e.target.checked)}
              />
              <span>Dinâmico</span>
            </label>
          </div>
          <button 
            className="close-btn"
            onClick={onClose}
          >
            ✕
          </button>
        </div>
      )}
      
      <svg ref={svgRef} className="network-svg"></svg>
      
      {hoveredNode && (
        <div className="node-tooltip" style={{
          left: hoveredNode.x + 10,
          top: hoveredNode.y - 20
        }}>
          <strong>{hoveredNode.label}</strong>
          {hoveredNode.agent && (
            <>
              <br />
              <span className="tooltip-role">{hoveredNode.agent.role}</span>
            </>
          )}
        </div>
      )}
      
      {!expanded && (
        <div className="network-legend">
          <div className="legend-item">
            <span className="legend-dot central"></span>
            <span>Central</span>
          </div>
          <div className="legend-item">
            <span className="legend-dot active"></span>
            <span>Ativo</span>
          </div>
        </div>
      )}
    </div>
  )
}

export default AgentNetworkMap